{"version":3,"sources":["../../src/utils/ObjectUtils.js"],"names":["isObject","val","getObjectForPath","path","newValue","elems","split","current","reverse","i","length","item","buildUpdateObjectSetValue","$set","createUpdate","obj","value","indexOf","Error","tpath","makeUpdate","objUpdate","result","Object","keys","forEach","key","undefined","isObjectEmpty","prop","hasOwnProperty"],"mappings":"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","file":"ObjectUtils.js","sourcesContent":["// candidate for deprecation totally unclear for what this method has been used\n// /**\n//  *\n//  * @param target\n//  * @param object\n//  * @param path\n//  * @returns {*}\n//  */\n// export const flattenObject = (target, object, path = '') => {\n//     for (var i in object) {\n//         if (object.hasOwnProperty(i)) {\n//             if (object[i] !== undefined) {\n//                 if (object[i] !== null) {\n//                     if (object[i] !== '') {\n//                         if (typeof object[i] === 'object') {\n//                             flattenObject(target, object[i], path === '' ? i : path + '.' + i)\n//                         } else if (Array.isArray(object[i])) {\n//                             // flatten array as comma separated list ?\n//                         } else {\n//                             if (Array.isArray(object)) {\n//                                 target[path === '' ? '[' + i + ']' : path + '[' + i + ']'] = object[i]\n//                             } else {\n//                                 target[path === '' ? i : path + '.' + i] = object[i]\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     return target\n// }\n\nexport const isObject = (val) => {\n    if (val === null) {\n        return false\n    }\n    return ((typeof val === 'function') || (typeof val === 'object'))\n}\n\nexport const getObjectForPath = (path, newValue) => {\n    //console.log('buildUpdateObject 1 ', path, newValue)\n    var elems = path.split('.')\n    var current\n    elems.reverse()\n    // console.log('buildUpdateObject 2 ', elems, elems.length)\n    for (var i = 0; i < elems.length; i++) {\n        // console.log('buildUpdateObject checking value 3', i, elems[i])\n        var item = elems[i]\n        if (i === 0) {\n            current = {\n                [item]: newValue\n\n            }\n        } else {\n            current = {\n                [item]: current\n            }\n        }\n    }\n\n    //console.log('buildUpdateObject returning', current)\n    return current\n}\n\n/**\n * this method creates a immutable update() object that can be used\n * to update an object.\n *\n * warning: this method does not create intermediate nodes\n *\n * @param path a dot separated property path\n * @param newValue the value to be set\n * @returns {*} the update() config\n */\nexport const buildUpdateObjectSetValue = (path, newValue) => {\n    //console.log('buildUpdateObject 1 ', path, newValue)\n    var elems = path.split('.')\n    var current\n    elems.reverse()\n    // console.log('buildUpdateObject 2 ', elems, elems.length)\n    for (var i = 0; i < elems.length; i++) {\n        // console.log('buildUpdateObject checking value 3', i, elems[i])\n        var item = elems[i]\n        if (i === 0) {\n            current = {\n                [item]: {\n                    $set: newValue\n                }\n            }\n        } else {\n            current = {\n                [item]: current\n            }\n        }\n    }\n\n    //console.log('buildUpdateObject returning', current)\n    return current\n}\n\nexport const createUpdate = (obj, path, value) => {\n    /**\n     * for now we explicitly NOT support array notation\n     *\n     * @type {{}}\n     */\n\n    if (path.indexOf('[') !== -1) {\n        throw new Error('Deep Set Update array notation not supported currently')\n    }\n\n    var tpath = getObjectForPath(path, value)\n\n    /**\n     *     we now need to insert the $set object at exactly the location\n     *     where an undefined prop exists\n     */\n    return makeUpdate(obj, tpath)\n}\n\nconst makeUpdate = (obj, objUpdate) => {\n    var result = {}\n\n    Object.keys(objUpdate)\n          .forEach((key) => {\n              // check if we have reached the leave node\n              if (isObject(objUpdate[key])) {\n                  if (obj[key] !== undefined) {\n                      /**\n                       * if the property exist, check if its structure\n                       * changed e.g. plain value to object, since we now\n                       * our new value is of type object, we need to\n                       * verify that existing value is object as well\n                       */\n                      if (isObject(obj[key])) {\n                          // if object go down that rabbit hole\n                          result = {[key]: makeUpdate(obj[key], objUpdate[key])}\n                      } else {\n                          // if its structure is different insert the $set directive here\n                          result = {[key]: {$set: objUpdate[key]}}\n                      }\n                  } else {\n                      // here we found a non existing property,\n                      // we need at this point to insert the $set directive\n                      // and set the whole remaining object\n\n                      result = {[key]: {$set: objUpdate[key]}}\n                  }\n              } else {\n                  // plain objects go as $set directlu\n                  result = {[key]: {$set: objUpdate[key]}}\n              }\n          })\n\n    return result\n}\n\n/**\n * checks of an object has at least one own property\n * @param obj\n * @returns {boolean}\n */\nexport const isObjectEmpty = (obj) => {\n    if (obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nexport default{\n    isObject,\n    isObjectEmpty,\n    getObjectForPath,\n    createUpdate,\n    buildUpdateObjectSetValue\n}\n"]}