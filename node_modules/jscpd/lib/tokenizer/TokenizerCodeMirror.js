// Generated by CoffeeScript 2.0.2
(function() {
  var CodeMirror, TokenizerBase, TokenizerCodeMirror, fs, logger, vm,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  vm = require("vm");

  fs = require("fs");

  TokenizerBase = require('./TokenizerBase');

  logger = require('winston');

  CodeMirror = require("codemirror/addon/runmode/runmode.node.js");

  CodeMirror.loadMode = function(name) {
    var filename;
    filename = require.resolve("codemirror/mode/" + name + "/" + name + ".js");
    return require(filename);
  };

  TokenizerCodeMirror = (function() {
    class TokenizerCodeMirror extends TokenizerBase {
      constructor() {
        super(...arguments);
        this.tokenize = this.tokenize.bind(this);
      }

      setTypeAndMode(language) {
        switch (language) {
          case "csharp":
          case "java":
          case "scala":
            this.type = 'clike';
            return this.mode = `text/${language}`;
          case 'typescript':
            this.type = 'javascript';
            return this.mode = `text/${language}`;
          case 'jsx':
            this.type = 'javascript';
            return this.mode = "text/javascript";
          default:
            this.type = language;
            return this.mode = language;
        }
      }

      loadType(type) {
        var e;
        try {
          CodeMirror.loadMode(type);
        } catch (error) {
          e = error;
          console.log(e);
          if (e.code === 'MODULE_NOT_FOUND') {
            logger.debug(`${e}`);
            console.error(`JSCPD Error 01: ${type} in not supported`);
          }
        }
        return this;
      }

      tokenize(code) {
        var e;
        boundMethodCheck(this, TokenizerCodeMirror);
        this.tokens = [];
        this.loadType(this.type);
        try {
          CodeMirror.runMode(code, this.mode, (value, tokenType, lineNumber) => {
            if (!lineNumber) {
              return;
            }
            tokenType = this.isEmptyToken(value) ? 'empty' : tokenType;
            tokenType = tokenType != null ? tokenType : 'default';
            return this.tokens.push([tokenType, value, lineNumber]);
          });
        } catch (error) {
          e = error;
          console.log('Error with language parsing');
          if (this.tokens.length === 0) {
            console.log(e);
          }
        }
        return this;
      }

      getType() {
        return this.type;
      }

      generateMap() {
        var currentMap, i, len, lineNumber, ref, tokensPositions, type, value;
        currentMap = "";
        tokensPositions = [];
        ref = this.tokens;
        for (i = 0, len = ref.length; i < len; i++) {
          [type, value, lineNumber] = ref[i];
          if (!(this.validToken(type))) {
            continue;
          }
          tokensPositions.push(lineNumber);
          currentMap = currentMap + this.createMap(type, value);
        }
        return {
          tokensPositions: tokensPositions,
          currentMap: currentMap
        };
      }

    };

    TokenizerCodeMirror.type = null;

    return TokenizerCodeMirror;

  })();

  module.exports = TokenizerCodeMirror;

}).call(this);
